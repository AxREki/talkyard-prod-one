version: '3.1'
services:
  web:
    image: debiki/ed-web:$VERSION_TAG
    restart: always
    volumes:
      - ./data/uploads/:/opt/ed/uploads/:ro
      - ./conf/web/listen.conf:/etc/nginx/listen.conf:ro
      #- ./conf/web/default-site/:/etc/nginx/default-site/:ro
      - ./data/sites-enabled/:/etc/nginx/sites-enabled/:ro
      - ./data/certbot/:/etc/certbot/:ro
      - ./data/certbot-challenges/.well-known/:/opt/nginx/html/.well-known/:ro
      # Mount here so standard monitoring tools looking for Nginx logs will work.
      - /var/log/nginx/:/var/log/nginx/
    ports:
      - '80:80'
      - '443:443'
    depends_on:
      - app
    sysctls:
      # Up the max backlog queue size (num connections per port), default = 128.
      # SHOULD check if this has any effect, although the host's /etc/sysctl.conf not changed
      net.core.somaxconn: 8192
    # SECURITY COULD drop capabilities, see: http://rhelblog.redhat.com/2016/10/17/secure-your-containers-with-this-one-weird-trick/
    # Ask at Hacker News: which caps can I drop for an Nginx container? A JVM appserver?
    # For all containers, not just 'web'.
    #cap_drop:
    #  - DAC_OVERRIDE
    #  ... many more?

  app:
    image: debiki/ed-app:$VERSION_TAG
    restart: always
    stdin_open: true  # otherwise Play Framework exits
    volumes:
      - ./conf/app/:/opt/ed/app-conf/:ro
      - ./data/uploads/:/opt/ed/uploads/
      # Mount here so log monitoring agents like fluentd can access the log.
      - /var/log/ed/:/var/log/ed/
    links:
      - cache
      - rdb
      - search
    environment:
      CONFIG_FILE: /opt/ed/app-conf/play.conf
      POSTGRES_PASSWORD: '$POSTGRES_PASSWORD'

  # SHOULD build my own Redis image for this, so I can auto upgrade the Redis config
  # by bumping the $VERSION_TAG.
  cache:
    image: redis:3.0.7-alpine
    restart: always
    volumes:
      - ./data/cache/:/data/
      - /var/log/redis/:/var/log/redis/

  rdb:
    image: debiki/ed-rdb:$VERSION_TAG
    restart: always
    volumes:
      - ./data/rdb/:/var/lib/postgresql/data/
      # Mount here so standard monitoring tools configured to find Postgres logs here will work.
      # (Inside the container, we don't mount in /var/lib/postgresql/data/pg_log/ because
      # then Postgres would refuse to create a db in data/, because data/ wouldn't be empty.)
      - /var/log/postgresql/:/var/log/postgresql/
    environment:
      POSTGRES_PASSWORD: '$POSTGRES_PASSWORD'
      # Optionally, streaming replication peer:
      # (but you'll need to rename ./postgres-data/recovery.conf.disabled first â€” and
      # that file isn't created until you start Postgres)
      # PEER_HOST: 'postgres2'
      # PEER_PORT: '5432'
      # PEER_PASSWORD: '...'

  search:
    # alpha4 unfortunately, because ElasticSearch clients for later versions cause a Netty JAR dependency conflict.
    # SHOULD upgrade, later: The ES team is creating a client that doesn't use Netty, + the Play Framework people are moving to some Akka HTTP stuff instead, wait for either of these to happen then upgrade.
    image: elasticsearch:5.0.0-alpha4
    restart: always
    volumes:
      - ./conf/search/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml:ro
      - ./data/search/:/usr/share/elasticsearch/data/
    sysctls:
      vm.max_map_count: 262144

  # (Do this later?)
  # This is a tiny Rust web server to which one POSTs /make-cert?domain=www.example.com
  # and which then calls Bash & certbot. The resulting cert is mounted :ro in Nginx, above.
  #certbot:
  #  image: debiki/ed-certbot:$VERSION_TAG
  #  command: certbot-server
  #  restart: always
  #  volumes:
  #    - ./data/certbot/:/etc/certbot/
  #    - ./data/certbot-challenges/.well-known/:/opt/webserver/html/.well-known/
  #
  # todo:
  #   docker-compose run --rm certbot certbot ...  ?

# vim: et ts=2 sw=2
